{"version":3,"sources":["../40dd3cd709791d666ad0.worker.js","../webpack/bootstrap 40dd3cd709791d666ad0","libs/Solver.worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","self","onmessage","e","data","moves","length","solvePuzzlePattern","solvePuzzleFringe","postMessage","cmd","solution","startSequence","allMoves","curArrayState","slice","concat","a","reconstructFromMoves","aArr","b","bArr","cArr","pattern","indexOf","start","toString","fringe","listCache","found","size","Math","sqrt","flimit","getHeuristics","fmin","Infinity","_loop2","_ret","_i2","fringeNode","g","parent","fringeArr","convertToNumArray","f","min","getMisplaced","nextStep","nextArr","move","unshift","expandNode","forEach","child","childG","index","splice","console","log","sequence","constructed","moveIndex","blankIndex","tempA","node","nodeArr","parentArr","possibleMoves","getAllMoves","blankParentIndex","childStrings","arr","newSequence","temp","temp2","Number","manhattan","getGridCoordinates","y","floor","x","getIndexByCoordinates","set","misplaced","cost","item","indexCoor","targetCoor","xMoves","abs","yMoves","str","split","blank","blankCoord","left","push","right","t"],"mappings":"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","file":"40dd3cd709791d666ad0.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/build/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nself.onmessage=function(e){if(e.data['cmd']==='solve'){var s=e.data['sequence'];var moves=s.length>10?solvePuzzlePattern(s):solvePuzzleFringe(s);self.postMessage({'cmd':'solved','solution':moves});}};var solvePuzzlePattern=function solvePuzzlePattern(startSequence){var allMoves=[];var moves=null;var curArrayState=startSequence.slice(0);moves=solvePuzzleFringe(curArrayState,[1,2,\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\"]);allMoves=allMoves.concat(moves);var a=reconstructFromMoves(moves,startSequence);var aArr=a.slice(0);moves=solvePuzzleFringe(aArr,[1,2,3,4,\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\"]);allMoves=allMoves.concat(moves);var b=reconstructFromMoves(moves,a);var bArr=b.slice(0);moves=solvePuzzleFringe(bArr,[1,2,3,4,5,\"x\",\"x\",\"x\",9,\"x\",\"x\",\"x\",13,\"x\",\"x\",\"x\"]);allMoves=allMoves.concat(moves);var c=reconstructFromMoves(moves,b);var cArr=c.slice(0);moves=solvePuzzleFringe(cArr,[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\"x\"]);allMoves=allMoves.concat(moves);return allMoves;};var solvePuzzleFringe=function solvePuzzleFringe(startSequence,pattern){//if there's a pattern, replace not used index in array with \"x\"\nif(pattern){var i=0;while(i<pattern.length-1){if(pattern[i]===\"x\")startSequence[startSequence.indexOf(i+1)]=\"x\";if(pattern[i]===\"o\")startSequence[startSequence.indexOf(i+1)]=\"o\";i++;}}var start=startSequence.toString();var fringe=[start];var listCache={};var found=false;var size=Math.sqrt(startSequence.length);var cost=1;var flimit=getHeuristics(startSequence,size);listCache[start]=[0,null];var moves=[];//let foundSequence = null;\nwhile(fringe.length>0&&!found){var fmin=Infinity;var _loop=function _loop(_i2){var fringeNode=fringe[_i2];var g=listCache[fringeNode][0];var parent=listCache[fringeNode][1];var fringeArr=convertToNumArray(fringeNode);var f=g+getHeuristics(fringeArr,size);if(f>flimit){fmin=Math.min(f,fmin);return'continue';}if(getMisplaced(fringeArr)===0){//console.log(\"found!!\" + fringeArr);\n//construct path back with lookup of parents stored in cache\nvar nextStep=fringeNode;while(nextStep){//move is number switched with blank (last num) between current and parent sequence\nvar nextArr=convertToNumArray(nextStep);var move=nextArr.indexOf(nextArr.length);nextStep=listCache[nextStep][1];if(nextStep)moves.unshift(move);}//foundSequence = fringeArr;\nfound=true;return'break';}var childNodes=expandNode(fringeNode,parent,size,pattern);//console.log(\"children: \" + childNodes);\nchildNodes.forEach(function(child){var childG=g+cost;if(listCache[child]){var cachedG=listCache[child][0];if(cachedG<=childG)return;}var index=fringe.indexOf(child);if(index!==-1){fringe.splice(index,1);if(index<=_i2)_i2--;}fringe.splice(_i2+1,0,child);listCache[child]=[childG,fringeNode];});fringe.splice(_i2,1);_i2--;_i=_i2;};_loop2:for(var _i=0;_i<fringe.length;_i++){var _ret=_loop(_i);switch(_ret){case'continue':continue;case'break':break _loop2;}}flimit=fmin;if(fringe.length===0)console.log(\"not found\");}return moves;};var reconstructFromMoves=function reconstructFromMoves(moves,sequence){var constructed=sequence;var i=0;while(i<moves.length){//swap move index with blank (last)\nvar moveIndex=moves[i];var blankIndex=constructed.indexOf(constructed.length);var tempA=constructed[moveIndex];constructed[moveIndex]=constructed.length;constructed[blankIndex]=tempA;i++;}return constructed;};var expandNode=function expandNode(node,parent,size,pattern){var nodeArr=convertToNumArray(node);var parentArr=parent?convertToNumArray(parent):null;//start node has no parent\nvar possibleMoves=getAllMoves(nodeArr,size);var blankParentIndex=!parent||!parentArr?null:parentArr.indexOf(parentArr.length);var childStrings=[];var blankIndex=nodeArr.indexOf(nodeArr.length);possibleMoves.forEach(function(move,index,arr){//const moveIndex = possibleMoves[i];\nif(move!==blankParentIndex){var newSequence=nodeArr.slice(0);var temp=newSequence[blankIndex];var temp2=nodeArr[move]===\"x\"?nodeArr[move]:Number(nodeArr[move]);newSequence[blankIndex]=temp2;newSequence[move]=temp;var s=newSequence.toString();childStrings.unshift(s);}});//childStrings = shuffleArray(childStrings);\nreturn childStrings;};var getHeuristics=function getHeuristics(sequence,size){return manhattan(sequence,size);};var getGridCoordinates=function getGridCoordinates(index,size){var y=Math.floor(index/size);var x=index-y*size;return{x:x,y:y};};var getIndexByCoordinates=function getIndexByCoordinates(x,y,size){return y*size+x;};var getMisplaced=function getMisplaced(set){var misplaced=0;var i=0;while(i<set.length){if(set[i]!==\"x\"&&set[i]!==i+1&&set[i]!==set.length)misplaced++;i++;}return misplaced;};var manhattan=function manhattan(set,size){var cost=0;set.forEach(function(item,index,arr){//get grid position of current index\nif(item===arr.length){//don't factor in last number used for blank\n}else{if(item===\"x\"){}else{var indexCoor=getGridCoordinates(index,size);//get grid position of target (number content of array - 1)\nvar targetCoor=getGridCoordinates(item-1,size);var xMoves=Math.abs(indexCoor.x-targetCoor.x);var yMoves=Math.abs(indexCoor.y-targetCoor.y);cost+=xMoves+yMoves;}}});return cost;};//to convert split string into array of numbers, (instead of strings as str.split('') does)\nvar convertToNumArray=function convertToNumArray(str){var arr=str.split(\",\");var i=0;while(i<arr.length){if(arr[i]!==\"x\")arr[i]=Number(arr[i]);i++;}return arr;};var getAllMoves=function getAllMoves(sequence,size){var moves=[];//find index of blank\nvar blank=sequence.indexOf(sequence.length);//get grid position of blank\nvar blankCoord=getGridCoordinates(blank,size);//add existing surrounding numbers to moves\nif(blankCoord.x>0){var left=getIndexByCoordinates(blankCoord.x-1,blankCoord.y,size);moves.push(left);}if(blankCoord.x<size-1){var right=getIndexByCoordinates(blankCoord.x+1,blankCoord.y,size);moves.push(right);}if(blankCoord.y>0){var t=getIndexByCoordinates(blankCoord.x,blankCoord.y-1,size);moves.push(t);}if(blankCoord.y<size-1){var b=getIndexByCoordinates(blankCoord.x,blankCoord.y+1,size);moves.push(b);}//moves = shuffleArray(moves);\nreturn moves;};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 40dd3cd709791d666ad0.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 40dd3cd709791d666ad0","\nself.onmessage = (e) => {\n\n    if(e.data['cmd'] === 'solve'){\n        let s = e.data['sequence'];\n        let moves = (s.length > 10) ? solvePuzzlePattern(s) : solvePuzzleFringe(s);\n        self.postMessage({'cmd':'solved','solution':moves});\n\n    }\n};\n\n\nconst solvePuzzlePattern = (startSequence) => {\n    let allMoves = [];\n    let moves = null;\n    let curArrayState = startSequence.slice(0);\n    moves = solvePuzzleFringe(curArrayState,[1,2,\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\"]);\n    allMoves = allMoves.concat(moves);\n    const a = reconstructFromMoves(moves,startSequence);\n    const aArr = a.slice(0);\n    moves = solvePuzzleFringe(aArr,[1,2,3,4,\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\"]);\n    allMoves = allMoves.concat(moves);\n    const b = reconstructFromMoves(moves,a);\n    const bArr = b.slice(0);\n    moves = solvePuzzleFringe(bArr,[1,2,3,4,5,\"x\",\"x\",\"x\",9,\"x\",\"x\",\"x\",13,\"x\",\"x\",\"x\"]);\n    allMoves = allMoves.concat(moves);\n    const c = reconstructFromMoves(moves,b);\n    const cArr = c.slice(0);\n    moves = solvePuzzleFringe(cArr,[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\"x\"]);\n    allMoves = allMoves.concat(moves);\n\n    return allMoves;\n};\n\nconst solvePuzzleFringe = (startSequence,pattern) => {\n\n    //if there's a pattern, replace not used index in array with \"x\"\n    if(pattern){\n        let i = 0;\n        while(i < pattern.length - 1){\n            if(pattern[i] === \"x\") startSequence[startSequence.indexOf(i + 1)] = \"x\";\n            if(pattern[i] === \"o\") startSequence[startSequence.indexOf(i + 1)] = \"o\";\n            i++;\n        }\n    }\n\n\n    let start = startSequence.toString();\n\n    const fringe = [start];\n    const listCache = {};\n\n\n    let found = false;\n    const size = (Math.sqrt(startSequence.length));\n    const cost = 1;\n    let flimit = getHeuristics(startSequence,size);\n    listCache[start] = [0,null];\n    const moves = [];\n    //let foundSequence = null;\n\n    while(fringe.length > 0 && !found){\n\n        let fmin = Infinity;\n\n        for(let i = 0; i< fringe.length; i++){\n\n            const fringeNode = fringe[i];\n            const g = listCache[fringeNode][0];\n            const parent = listCache[fringeNode][1];\n            const fringeArr = convertToNumArray(fringeNode);\n            const f = g + getHeuristics(fringeArr,size);\n\n            if(f > flimit){\n                fmin = Math.min(f,fmin);\n                continue;\n            }\n\n            if(getMisplaced(fringeArr) === 0){\n                //console.log(\"found!!\" + fringeArr);\n                //construct path back with lookup of parents stored in cache\n\n                let nextStep = fringeNode;\n                while(nextStep){\n\n                    //move is number switched with blank (last num) between current and parent sequence\n                    const nextArr = convertToNumArray(nextStep);\n                    const move = nextArr.indexOf(nextArr.length);\n                    nextStep = listCache[nextStep][1];\n                    if(nextStep)moves.unshift(move);\n\n                }\n\n                //foundSequence = fringeArr;\n                found = true;\n                break;\n\n            }\n\n            const childNodes = expandNode(fringeNode,parent,size,pattern);\n\n            //console.log(\"children: \" + childNodes);\n            childNodes.forEach((child)=> {\n                const childG = g + cost;\n                if(listCache[child]){\n                    let cachedG = listCache[child][0];\n                    if(cachedG <= childG) return;\n                }\n\n                const index = fringe.indexOf(child);\n                if(index !== -1){\n                    fringe.splice(index,1);\n                    if(index <= i) i--;\n                }\n\n                fringe.splice(i + 1,0,child);\n                listCache[child] = [childG,fringeNode];\n            });\n\n            fringe.splice(i,1);\n            i--;\n\n        }\n\n        flimit = fmin;\n\n        if(fringe.length === 0) console.log(\"not found\");\n    }\n\n    return moves;\n\n};\n\nconst reconstructFromMoves = (moves,sequence) => {\n    let constructed = sequence;\n    let i = 0;\n    while(i < moves.length){\n\n        //swap move index with blank (last)\n        const moveIndex = moves[i];\n        const blankIndex = constructed.indexOf(constructed.length);\n        const tempA = constructed[moveIndex];\n        constructed[moveIndex] = constructed.length;\n        constructed[blankIndex] = tempA;\n\n\n        i++;\n    }\n\n\n    return constructed;\n};\n\n\nconst expandNode = (node, parent, size, pattern) => {\n\n    const nodeArr = convertToNumArray(node);\n    const parentArr = (parent) ? convertToNumArray(parent) : null;//start node has no parent\n    const possibleMoves = getAllMoves(nodeArr, size);\n    const blankParentIndex = (!parent || !parentArr) ? null :parentArr.indexOf(parentArr.length);\n\n    let childStrings = [];\n    const blankIndex = nodeArr.indexOf(nodeArr.length);\n\n    possibleMoves.forEach((move,index,arr) => {\n\n        //const moveIndex = possibleMoves[i];\n\n        if(move !== blankParentIndex){\n            const newSequence = nodeArr.slice(0);\n            const temp = newSequence[blankIndex];\n            const temp2 = (nodeArr[move] === \"x\") ? nodeArr[move] : Number(nodeArr[move]);\n            newSequence[blankIndex] = temp2;\n            newSequence[move] = temp;\n            const s = newSequence.toString();\n            childStrings.unshift(s);\n        }\n\n\n\n    });\n\n\n    //childStrings = shuffleArray(childStrings);\n    return childStrings;\n};\n\n\nconst getHeuristics = (sequence, size) => {\n    return manhattan(sequence,size);\n\n};\n\nconst getGridCoordinates = (index,size) => {\n\n    const y = Math.floor(index/size);\n    const x = index - (y * size);\n\n    return {x:x,y:y};\n\n};\n\nconst getIndexByCoordinates = (x,y,size) => {\n    return (y * size) + x;\n\n};\n\n\nconst getMisplaced = (set) => {\n    let misplaced = 0;\n    let i = 0;\n    while(i < set.length){\n        if(set[i] !== \"x\" && set[i] !== (i + 1) && set[i] !== set.length) misplaced++;\n        i++;\n    }\n\n    return misplaced;\n\n};\n\nconst manhattan = (set, size) => {\n    let cost = 0;\n\n    set.forEach((item, index, arr) => {\n        //get grid position of current index\n        if(item === arr.length){\n            //don't factor in last number used for blank\n        }else{\n            if(item === \"x\"){\n\n            }else{\n                let indexCoor = getGridCoordinates(index, size);\n                //get grid position of target (number content of array - 1)\n\n                let targetCoor = getGridCoordinates(item - 1, size);\n                let xMoves = Math.abs(indexCoor.x - targetCoor.x);\n                let yMoves = Math.abs(indexCoor.y - targetCoor.y);\n\n                cost += (xMoves + yMoves)\n            }\n\n        }\n\n    });\n\n    return cost;\n\n};\n\n\n//to convert split string into array of numbers, (instead of strings as str.split('') does)\nconst convertToNumArray = (str) => {\n    const arr = str.split(\",\");\n    let i = 0;\n    while(i < arr.length){\n\n        if(arr[i] !== \"x\") arr[i] = Number(arr[i]);\n        i++;\n    }\n\n    return arr;\n};\n\n\nconst getAllMoves = (sequence, size) => {\n\n    let moves = [];\n\n    //find index of blank\n    const blank = sequence.indexOf(sequence.length);\n    //get grid position of blank\n    const blankCoord = getGridCoordinates(blank,size);\n    //add existing surrounding numbers to moves\n\n    if(blankCoord.x > 0) {\n        const left = getIndexByCoordinates(blankCoord.x - 1, blankCoord.y, size);\n        moves.push(left);\n    }\n\n    if(blankCoord.x < size - 1){\n        const right = getIndexByCoordinates(blankCoord.x + 1,blankCoord.y, size);\n        moves.push(right);\n    }\n\n    if(blankCoord.y > 0){\n        const t = getIndexByCoordinates(blankCoord.x,blankCoord.y - 1, size);\n        moves.push(t);\n    }\n\n    if(blankCoord.y < size - 1){\n        const b = getIndexByCoordinates(blankCoord.x,blankCoord.y + 1, size);\n        moves.push(b);\n    }\n\n    //moves = shuffleArray(moves);\n    return moves;\n};\n\n\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/libs/Solver.worker.js"],"sourceRoot":""}